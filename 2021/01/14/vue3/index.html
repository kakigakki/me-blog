<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue3学习笔记 | KAKi BLOG</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="vue3 的生命周期
20210116123441
vue3 中的beforeCreat和created都可以用setup替代
vue3 中的beforeDestroy和`d ...">
    <link rel="preload" href="/me-blog/assets/css/0.styles.160a852d.css" as="style"><link rel="preload" href="/me-blog/assets/js/app.4b1a192a.js" as="script"><link rel="preload" href="/me-blog/assets/js/6.28c07464.js" as="script"><link rel="preload" href="/me-blog/assets/js/3.db7e6e2f.js" as="script"><link rel="preload" href="/me-blog/assets/js/24.4930b6be.js" as="script"><link rel="prefetch" href="/me-blog/assets/js/10.79eede31.js"><link rel="prefetch" href="/me-blog/assets/js/11.55973fd1.js"><link rel="prefetch" href="/me-blog/assets/js/12.9578c04b.js"><link rel="prefetch" href="/me-blog/assets/js/13.dcb99cce.js"><link rel="prefetch" href="/me-blog/assets/js/14.5beb0ec8.js"><link rel="prefetch" href="/me-blog/assets/js/15.f58825d9.js"><link rel="prefetch" href="/me-blog/assets/js/16.3ee014d3.js"><link rel="prefetch" href="/me-blog/assets/js/17.88b8ce45.js"><link rel="prefetch" href="/me-blog/assets/js/18.78fcb414.js"><link rel="prefetch" href="/me-blog/assets/js/19.56424686.js"><link rel="prefetch" href="/me-blog/assets/js/20.d8b5c6da.js"><link rel="prefetch" href="/me-blog/assets/js/21.5ae38ab1.js"><link rel="prefetch" href="/me-blog/assets/js/22.6f9be2d0.js"><link rel="prefetch" href="/me-blog/assets/js/23.1040e7cc.js"><link rel="prefetch" href="/me-blog/assets/js/25.b2addafc.js"><link rel="prefetch" href="/me-blog/assets/js/26.4c8fdf59.js"><link rel="prefetch" href="/me-blog/assets/js/27.d70545a0.js"><link rel="prefetch" href="/me-blog/assets/js/28.47ac6ea1.js"><link rel="prefetch" href="/me-blog/assets/js/29.d1a8312e.js"><link rel="prefetch" href="/me-blog/assets/js/30.abf11326.js"><link rel="prefetch" href="/me-blog/assets/js/31.66095ccb.js"><link rel="prefetch" href="/me-blog/assets/js/32.48bd6ca5.js"><link rel="prefetch" href="/me-blog/assets/js/33.a394a180.js"><link rel="prefetch" href="/me-blog/assets/js/34.9142e80a.js"><link rel="prefetch" href="/me-blog/assets/js/35.eddeb958.js"><link rel="prefetch" href="/me-blog/assets/js/36.dc234639.js"><link rel="prefetch" href="/me-blog/assets/js/37.d2e7e290.js"><link rel="prefetch" href="/me-blog/assets/js/38.b7b6900f.js"><link rel="prefetch" href="/me-blog/assets/js/39.3ddc72c6.js"><link rel="prefetch" href="/me-blog/assets/js/4.9ce64a3d.js"><link rel="prefetch" href="/me-blog/assets/js/40.04d82849.js"><link rel="prefetch" href="/me-blog/assets/js/41.4bb08b11.js"><link rel="prefetch" href="/me-blog/assets/js/42.91f194df.js"><link rel="prefetch" href="/me-blog/assets/js/43.04bbe10d.js"><link rel="prefetch" href="/me-blog/assets/js/44.c1594f17.js"><link rel="prefetch" href="/me-blog/assets/js/45.5cfd9196.js"><link rel="prefetch" href="/me-blog/assets/js/5.61e04663.js"><link rel="prefetch" href="/me-blog/assets/js/7.7f74546b.js"><link rel="prefetch" href="/me-blog/assets/js/8.a9b0d16e.js"><link rel="prefetch" href="/me-blog/assets/js/9.33795499.js"><link rel="prefetch" href="/me-blog/assets/js/vuejs-paginate.3eb1ed69.js">
    <link rel="stylesheet" href="/me-blog/assets/css/0.styles.160a852d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/me-blog/" class="nav-link home-link">KAKi BLOG </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header> <div class="colorPicker themeColorPicker" data-v-7280d5ff><button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button></div></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/me-blog/" class="nav-link mobile-home-link">KAKi BLOG </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="mobile-nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="mobile-nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="mobile-nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Vue3学习笔记
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">kaki</span> <span itemprop="address">   in Tokyo</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-01-14T00:00:00.000Z">
      Thu Jan 14 2021
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-f41abf76><a href="/me-blog/tag/vue" data-v-f41abf76><span data-v-f41abf76>vue</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="vue3-的生命周期"><a href="#vue3-的生命周期" class="header-anchor">#</a> vue3 的生命周期</h3> <p><img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210116123441.png" alt="20210116123441"></p> <ul><li><p>vue3 中的<code>beforeCreat</code>和<code>created</code>都可以用<code>setup</code>替代</p></li> <li><p>vue3 中的<code>beforeDestroy</code>和<code>destroyed</code>都已经不存在，用<code>beforeUnmount</code>和<code>unmounted</code>替代</p></li> <li><p>vue3 中的推荐使用组合 API 的方式来使用声明周期，因为会 vue2 中的使用方法来得快
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210116124806.png" alt="20210116124806"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>onMounted<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span>

<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//在此执行操作</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="composition-api"><a href="#composition-api" class="header-anchor">#</a> Composition API</h2> <h3 id="setup"><a href="#setup" class="header-anchor">#</a> setup</h3> <h4 id="特性"><a href="#特性" class="header-anchor">#</a> 特性</h4> <ul><li>新的 option，所有的组合 API 函数都在此使用，只在初始化时执行一次</li> <li>函数如果返回对象，对象中的属性或者方法，都可以再模板中直接使用</li> <li>组合 API 的入口</li></ul> <h4 id="细节"><a href="#细节" class="header-anchor">#</a> 细节</h4> <ul><li><p>setup 在<code>beforeCreat</code>之前执行，即，setup 在执行的时候，组件还没创建出来，即组件的 this 还处于<code>undefined</code>状态，无法通过 this 来访问<code>data/computed/methods/props</code></p></li> <li><p>setup 中<code>返回对象</code>中的属性会与<code>data函数</code>返回的对象的属性合并为组件对象的属性(如果重名，setup 优先，如果 setup 就别使用 data 了)</p></li> <li><p>setup 中<code>返回对象</code>中的方法会与<code>methods对象</code>中的方法合并为组件对象的方法(如果重名，setup 优先,如果 setup 就别使用 methods 了)</p></li></ul> <h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <p>setup 中有两个参数<code>props</code>与<code>context</code></p> <ul><li><code>props</code> : 是一个对象，里面有父级组件向子级组件传递的数据</li> <li><code>context</code>：是一个对象，有一个<code>attrs</code>对象，<code>emit</code>方法，<code>slots</code>对象
<ul><li><code>context.attrs</code> ： 是一个对象，包含在当前组件中标签中声明的所有属性的对象（不包含 props 中的），</li> <li><code>context.emit</code> ： 跟<code>vue2</code>中的<code>this.emit</code></li> <li><code>context.slots</code></li></ul></li></ul> <h3 id="ref"><a href="#ref" class="header-anchor">#</a> ref</h3> <h4 id="特性-2"><a href="#特性-2" class="header-anchor">#</a> 特性</h4> <ul><li><p>一个定义响应式数据的函数</p></li> <li><p>返回一个 Ref 对象，对象中有一个 Value 属性，</p> <ul><li>如果需要对数据进行操作，需要使用该 Ref 对象调用 value 属性</li> <li>html 模板中不需要使用调用 value 属性</li></ul></li> <li><p>一般用于基本类型的响应式设定</p></li> <li><p>vue2 中的<code>this.$ref</code>也是用这个<code>ref</code>来实现</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token string">&quot;myInput&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">&gt;</span>

<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> myInput <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    myInput<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span><span class="token punctuation">{</span>
    myInput
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></li></ul> <h4 id="细节-2"><a href="#细节-2" class="header-anchor">#</a> 细节</h4> <ul><li><code>ref方法</code>中也可以传一个对象，此时 vue3 会自动将 ref 返回值中的 value 自动包装成<code>reactive</code>对象（不推荐使用）</li></ul> <h3 id="reactive"><a href="#reactive" class="header-anchor">#</a> reactive</h3> <ul><li>定义多个数据的响应式（对象响应）</li> <li>将目标对象通过 proxy 代理，实现对象的深层次响应式</li></ul> <h3 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h3> <h4 id="特性-3"><a href="#特性-3" class="header-anchor">#</a> 特性</h4> <ul><li><p>使用方法与 vue2 中有所不同,<code>computed</code>函数返回的是一个<code>ref</code>对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//计算属性函数中如果只传入一个回调函数，表示get</span>
  <span class="token keyword">const</span> name1 <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> xxx <span class="token operator">+</span> xxx
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">//计算属性函数中如果传入一个对象，可以有get,set方法</span>
  <span class="token keyword">const</span> name2 <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">,</span>
    name2
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="watch-watcheffect"><a href="#watch-watcheffect" class="header-anchor">#</a> watch&amp;watchEffect</h3> <h4 id="特性-4"><a href="#特性-4" class="header-anchor">#</a> 特性</h4> <ul><li><p><code>watch</code>使用方法与 vue2 中有所不同</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> name1<span class="token operator">:</span> <span class="token string">'kaki'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token comment">//第一个参数表示监视内容（可以是对象)</span>
<span class="token comment">//第二个参数监视内容改变后的回调函数，回调函数的参数为newVal,oldVal</span>
<span class="token comment">//第三个参数可以配置一些监视的属性,immediate表示初始化时执行一次，deep表示对对象的深层次监视</span>
<span class="token function">watch</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name1<span class="token punctuation">,</span>age<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  name<span class="token punctuation">.</span>value <span class="token operator">=</span> name1<span class="token operator">+</span>age
<span class="token punctuation">}</span>，<span class="token punctuation">{</span>immediate<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>deep<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div></li> <li><p><code>watch</code>可以指定多个监视内容</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>user<span class="token punctuation">,</span> user1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//此时newVal,oldVal也是数组[newUser,newUser1],[oldUser,oldUser1]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p><code>watch</code>监视的数据如果是非响应式的数据，如对象中的属性，那么需要使用回调的方法对它进行一层包装</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> user<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> user<span class="token punctuation">.</span>age<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">new</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token comment">//此时才能监视到name,age</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <ul><li><p><code>watchEffect</code>为 vue3 中特有的，</p></li> <li><p>不用直接指定要监视的内容，直接在回调函数中操作需要监视的内容</p></li> <li><p>不需要像<code>watch</code>中配置<code>immediate</code>就可以默认执行一次</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">.</span>value <span class="token operator">=</span> name1 <span class="token operator">+</span> age
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="shallowreactive-shallowref"><a href="#shallowreactive-shallowref" class="header-anchor">#</a> shallowReactive &amp;&amp; shallowRef</h3> <p>浅劫持，浅监视。有时候为了提高性能，不需要深层次监视某个对象时，可以使用</p> <h3 id="readonly-shallowreadonly"><a href="#readonly-shallowreadonly" class="header-anchor">#</a> readonly &amp;&amp; shallowReadonly</h3> <ul><li><code>readonly(obj)</code>定义一个对象为只读，无法进行修改（深）</li> <li><code>shallowReadonly(obj)</code> 定义一个对象为只读，无法进行修改（浅）</li></ul> <h3 id="toraw-markraw"><a href="#toraw-markraw" class="header-anchor">#</a> toRaw &amp;&amp; markRaw</h3> <ul><li><code>toRaw(obj)</code> 将代理对象变为普通对象，即数据变化，界面不再变化</li> <li><code>obj.list = markRaw([1,2,3,4])</code> 将代理对象的某个数据弄成非响应式数据</li></ul> <h3 id="toref"><a href="#toref" class="header-anchor">#</a> toRef</h3> <ul><li><code>toRef(proxy,val)</code>将响应式对象的属性变成 ref 对象
当父子组件传递<code>prop属性</code>时，子组件接收到的父组件的 ref 对象的值时，一般都会接收到 <code>ref</code>的<code>value</code>，此时希望在子组件中将此数据变成 ref 对象，且与父组件相互响应时，则可以使用<code>toRef</code></li></ul> <h3 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> provide &amp;&amp; inject</h3> <p>能够提供祖父与孙子组件之间的通信</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//祖父组件中提供</span>
<span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">//孙子组件中注入</span>
<span class="token keyword">const</span> xx <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="isref-isreactive-isreadonly-isproxy"><a href="#isref-isreactive-isreadonly-isproxy" class="header-anchor">#</a> isRef &amp;&amp; isReactive &amp;&amp; isReadonly &amp;&amp; isProxy</h3> <ul><li><code>isRef</code>:检查一个值是否为一个 ref 对象</li> <li><code>isReactive</code>：检查一个对象是否为 reactive 创建的响应式代理</li> <li><code>isReadonly</code>：检查一个对象是否是由 readonly 创建的只读代理</li> <li><code>isProxy</code>：检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</li></ul> <h3 id="手写组合-api"><a href="#手写组合-api" class="header-anchor">#</a> 手写组合 API</h3> <h4 id="shallowreactive-reactive"><a href="#shallowreactive-reactive" class="header-anchor">#</a> shallowReactive &amp;&amp; reactive</h4> <p>主要用<code>proxy</code>与<code>reflect</code>进行手写</p> <h4 id="shallowreadonly-readonly"><a href="#shallowreadonly-readonly" class="header-anchor">#</a> shallowReadonly &amp;&amp; readonly</h4> <p>主要用<code>proxy</code>与<code>reflect</code>进行手写</p> <h4 id="shallowref-ref"><a href="#shallowref-ref" class="header-anchor">#</a> shallowRef &amp;&amp; ref</h4> <p>主要利用<code>get</code>和<code>set</code>进行手写</p> <h4 id="isref-isreactive-isreadonly-isproxy-2"><a href="#isref-isreactive-isreadonly-isproxy-2" class="header-anchor">#</a> isRef,isReactive,isReadonly,isProxy</h4> <p>主要在创建内部对象时创建内部属性进行判断</p> <h3 id="fragment-teleport"><a href="#fragment-teleport" class="header-anchor">#</a> fragment &amp;&amp; teleport</h3> <ul><li><p><code>fragment</code> 组件可以没有根标签，内部会将多个标签包含在一个 Fragment 虚拟元素中，可以减少标签层级，减少内存占用</p></li> <li><p><code>teleport</code>标签 可以让某段 html 跑到指定位置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>teleport to<span class="token operator">:</span><span class="token string">&quot;body&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>teleport<span class="token operator">&gt;</span>
</code></pre></div></li></ul> <h3 id="suspense"><a href="#suspense" class="header-anchor">#</a> Suspense</h3> <p>允许我们的应用程序在等待异步组件的时候，渲染一些后备内容，可以让我们创建一个平滑的用户体验
vue3 中动态引入组件与 vue2 中有所不同</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//父组件中html</span>
<span class="token operator">&lt;</span>Suspense<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>template v<span class="token operator">-</span>slot<span class="token operator">:</span><span class="token keyword">default</span><span class="token operator">&gt;</span> <span class="token comment">//或者写成#default</span>
    <span class="token operator">&lt;</span>AsyncComp<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>AsyncComp<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>template v<span class="token operator">-</span>slot<span class="token operator">:</span>fallback<span class="token operator">&gt;</span>
    loading
  <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>

<span class="token comment">//动态组件依旧是异步的</span>
<span class="token keyword">const</span> AsyncComp <span class="token operator">=</span> <span class="token function">definedAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>i <span class="token function">mport</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//如果组件中的setup返回的是promise对象，那么此组件也是异步组件</span>
<span class="token comment">//AsyncComp组件中setup</span>
<span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    data<span class="token operator">:</span>res<span class="token punctuation">.</span>data
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vite"><a href="#vite" class="header-anchor">#</a> Vite</h2> <h3 id="亮点"><a href="#亮点" class="header-anchor">#</a> 亮点</h3> <ol><li><p>地址解析
不管是<code>script</code>中还是<code>style</code>中还是<code>html</code>中的地址在 vite 中都会用同样的方法解析,所以这些位置都可以使用别名</p></li> <li><p>css 可以通过模块引入</p></li></ol> <div class="language-html extra-class"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>classes.logo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span>
import classes from './App.module.css'
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><ol><li><p>vue3 中的 setup script</p> <ul><li><p>可以在<code>vue</code>文件中的<code>script</code>标签直接加上<code>setup</code>属性,来直接将整个<code>ts</code>部分包含在 setup 启动函数中</p></li> <li><p>导入组件后可以直接使用</p></li> <li><p><code>difneProps({})</code>可以直接定义属性
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210326001202.png" alt="20210326001202"></p></li> <li><p><code>defineEmit</code> 可以定义事件
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210326001141.png" alt="20210326001141"></p></li> <li><p><code>useContext</code> 定义上下文
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210326001441.png" alt="20210326001441"></p></li></ul></li></ol> <h3 id="插件"><a href="#插件" class="header-anchor">#</a> 插件</h3> <p>当用户请求时,都会经过一下插件.这就有点像有点像过滤器,也有点像中间件.</p> <ol><li>插件的形式</li></ol> <p><img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210325234253.png" alt="20210325234253"></p> <ol><li>插件的钩子
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20210325233644.png" alt="20210325233644"></li></ol> <h3 id=""><a href="#" class="header-anchor">#</a></h3></div> <footer><!----> <hr> <p class="lastUpdated">最後更新：2021/04/15</p> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#生命周期" title="生命周期">生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#vue3-的生命周期" title="vue3 的生命周期">vue3 的生命周期</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#composition-api" title="Composition API">Composition API</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#setup" title="setup">setup</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ref" title="ref">ref</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#reactive" title="reactive">reactive</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#computed" title="computed">computed</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#watch-watcheffect" title="watch&amp;watchEffect">watch&amp;watchEffect</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#shallowreactive-shallowref" title="shallowReactive &amp;&amp; shallowRef">shallowReactive &amp;&amp; shallowRef</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#readonly-shallowreadonly" title="readonly &amp;&amp; shallowReadonly">readonly &amp;&amp; shallowReadonly</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#toraw-markraw" title="toRaw &amp;&amp; markRaw">toRaw &amp;&amp; markRaw</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#toref" title="toRef">toRef</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#provide-inject" title="provide &amp;&amp; inject">provide &amp;&amp; inject</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#isref-isreactive-isreadonly-isproxy" title="isRef &amp;&amp; isReactive &amp;&amp; isReadonly &amp;&amp; isProxy">isRef &amp;&amp; isReactive &amp;&amp; isReadonly &amp;&amp; isProxy</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#手写组合-api" title="手写组合 API">手写组合 API</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#fragment-teleport" title="fragment &amp;&amp; teleport">fragment &amp;&amp; teleport</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#suspense" title="Suspense">Suspense</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#vite" title="Vite">Vite</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#亮点" title="亮点">亮点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#插件" title="插件">插件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#" title=""></a></div></div></div></div> <footer class="footer" data-v-9908f194><div class="footer-left-wrap" data-v-9908f194><ul class="contact" data-v-9908f194><li class="contact-item" data-v-9908f194><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-9908f194><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-9908f194></path></svg>
          
        </a></li><li class="contact-item" data-v-9908f194><a href="/me-blog/2021/01/14/vue3/kakigakki@gmail.com.html" class="nav-link" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-9908f194><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-9908f194></path><polyline points="22,6 12,13 2,6" data-v-9908f194></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-9908f194><ul class="copyright" data-v-9908f194></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/me-blog/assets/js/app.4b1a192a.js" defer></script><script src="/me-blog/assets/js/6.28c07464.js" defer></script><script src="/me-blog/assets/js/3.db7e6e2f.js" defer></script><script src="/me-blog/assets/js/24.4930b6be.js" defer></script>
  </body>
</html>
