<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react学习笔记 | KAKi BLOG</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="
JSX 语法

JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由 Babel 的 JSX 编译器实现。

Class 组件

ES6 的加入让 JavaScrip ...">
    <link rel="preload" href="/me-blog/assets/css/0.styles.160a852d.css" as="style"><link rel="preload" href="/me-blog/assets/js/app.4b1a192a.js" as="script"><link rel="preload" href="/me-blog/assets/js/6.28c07464.js" as="script"><link rel="preload" href="/me-blog/assets/js/3.db7e6e2f.js" as="script"><link rel="preload" href="/me-blog/assets/js/21.5ae38ab1.js" as="script"><link rel="prefetch" href="/me-blog/assets/js/10.79eede31.js"><link rel="prefetch" href="/me-blog/assets/js/11.55973fd1.js"><link rel="prefetch" href="/me-blog/assets/js/12.9578c04b.js"><link rel="prefetch" href="/me-blog/assets/js/13.dcb99cce.js"><link rel="prefetch" href="/me-blog/assets/js/14.5beb0ec8.js"><link rel="prefetch" href="/me-blog/assets/js/15.f58825d9.js"><link rel="prefetch" href="/me-blog/assets/js/16.3ee014d3.js"><link rel="prefetch" href="/me-blog/assets/js/17.88b8ce45.js"><link rel="prefetch" href="/me-blog/assets/js/18.78fcb414.js"><link rel="prefetch" href="/me-blog/assets/js/19.56424686.js"><link rel="prefetch" href="/me-blog/assets/js/20.d8b5c6da.js"><link rel="prefetch" href="/me-blog/assets/js/22.6f9be2d0.js"><link rel="prefetch" href="/me-blog/assets/js/23.1040e7cc.js"><link rel="prefetch" href="/me-blog/assets/js/24.4930b6be.js"><link rel="prefetch" href="/me-blog/assets/js/25.b2addafc.js"><link rel="prefetch" href="/me-blog/assets/js/26.4c8fdf59.js"><link rel="prefetch" href="/me-blog/assets/js/27.d70545a0.js"><link rel="prefetch" href="/me-blog/assets/js/28.47ac6ea1.js"><link rel="prefetch" href="/me-blog/assets/js/29.d1a8312e.js"><link rel="prefetch" href="/me-blog/assets/js/30.abf11326.js"><link rel="prefetch" href="/me-blog/assets/js/31.66095ccb.js"><link rel="prefetch" href="/me-blog/assets/js/32.48bd6ca5.js"><link rel="prefetch" href="/me-blog/assets/js/33.a394a180.js"><link rel="prefetch" href="/me-blog/assets/js/34.9142e80a.js"><link rel="prefetch" href="/me-blog/assets/js/35.eddeb958.js"><link rel="prefetch" href="/me-blog/assets/js/36.dc234639.js"><link rel="prefetch" href="/me-blog/assets/js/37.d2e7e290.js"><link rel="prefetch" href="/me-blog/assets/js/38.b7b6900f.js"><link rel="prefetch" href="/me-blog/assets/js/39.3ddc72c6.js"><link rel="prefetch" href="/me-blog/assets/js/4.9ce64a3d.js"><link rel="prefetch" href="/me-blog/assets/js/40.04d82849.js"><link rel="prefetch" href="/me-blog/assets/js/41.4bb08b11.js"><link rel="prefetch" href="/me-blog/assets/js/42.91f194df.js"><link rel="prefetch" href="/me-blog/assets/js/43.04bbe10d.js"><link rel="prefetch" href="/me-blog/assets/js/44.c1594f17.js"><link rel="prefetch" href="/me-blog/assets/js/45.5cfd9196.js"><link rel="prefetch" href="/me-blog/assets/js/5.61e04663.js"><link rel="prefetch" href="/me-blog/assets/js/7.7f74546b.js"><link rel="prefetch" href="/me-blog/assets/js/8.a9b0d16e.js"><link rel="prefetch" href="/me-blog/assets/js/9.33795499.js"><link rel="prefetch" href="/me-blog/assets/js/vuejs-paginate.3eb1ed69.js">
    <link rel="stylesheet" href="/me-blog/assets/css/0.styles.160a852d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/me-blog/" class="nav-link home-link">KAKi BLOG </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header> <div class="colorPicker themeColorPicker" data-v-7280d5ff><button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button></div></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/me-blog/" class="nav-link mobile-home-link">KAKi BLOG </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="mobile-nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="mobile-nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="mobile-nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        react学习笔记
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">kaki</span> <span itemprop="address">   in Tokyo</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2022-04-14T00:00:00.000Z">
      Thu Apr 14 2022
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-f41abf76><a href="/me-blog/tag/javaScript" data-v-f41abf76><span data-v-f41abf76>javaScript</span></a></li><li class="post-tag" data-v-f41abf76><a href="/me-blog/tag/react" data-v-f41abf76><span data-v-f41abf76>react</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="jsx-语法与组件"><a href="#jsx-语法与组件" class="header-anchor">#</a> JSX 语法与组件</h2> <h3 id="jsx-语法"><a href="#jsx-语法" class="header-anchor">#</a> JSX 语法</h3> <p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由 Babel 的 JSX 编译器实现。</p> <h3 id="class-组件"><a href="#class-组件" class="header-anchor">#</a> Class 组件</h3> <p>ES6 的加入让 JavaScript 直接支持使用 class 来定义一个类，react 创建组件的方式就是使用的类的继承，ES6 class 是目前官方推荐的使用方式，它使用了 ES6 标准语法来构建，看以下代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>欢迎进入React的世界<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>es6 class 组件其实就是一个构造器,每次使用组件都相当于在实例化组件.</p> <h3 id="函数式组件"><a href="#函数式组件" class="header-anchor">#</a> 函数式组件</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span>
<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>欢迎进入React的世界<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token comment">// React组件的调用方式</span>
  <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><p>这样一个完整的函数式组件就定义好了。但要注意！注意！注意！组件名必须大写，否则报错</p> <h3 id="组件的样式"><a href="#组件的样式" class="header-anchor">#</a> 组件的样式</h3> <ol><li><p>行内样式
想给虚拟 dom 添加行内样式，需要使用表达式传入样式对象的方式来实现：行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如 render 函数里、组件原型上、外链 js 文件中</p></li> <li><p>使用 class
其实我们大多数情况下还是大量的在为元素添加类名，但是需要注意的是， class 需要写成className （因为毕竟是在写类 js 代码，会收到 js 规则的现在，而 class 是关键字</p></li></ol> <h3 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h3> <ol><li><p>绑定事件
采用 on+事件名的方式来绑定一个事件，注意，这里和原生的事件是有区别的，原生的事件全是小写onclick , React 里的事件是驼峰 onClick ，React 的事件并不是原生事件，而是合成事件。</p></li> <li><p>事件 handler 的写法</p></li></ol> <ul><li>直接在 render 里写行内的箭头函数(不推荐)</li> <li>在组件内使用箭头函数定义一个方法(<strong>推荐</strong>)</li> <li>直接在组件内定义一个非箭头函数的方法，然后在 render 里直接使用 onClick={this.handleClick.bind(this)} (不推荐)</li> <li>直接在组件内定义一个非箭头函数的方法，然后在 constructor 里 bind(this)(<strong>推荐</strong>)</li></ul> <ol start="3"><li>Event 对象
和普通浏览器一样，事件 handler 会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React 中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有 event.stopPropagation 、event.preventDefault 这种常用的方法</li></ol> <h3 id="ref-的应用"><a href="#ref-的应用" class="header-anchor">#</a> Ref 的应用</h3> <ol><li>类组件写法</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span><span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">//访问this.myRef.current</span>
</code></pre></div><ol start="2"><li>函数组件写法</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>myRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>myRef<span class="token punctuation">}</span><span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">//访问this.myRef.current</span>
</code></pre></div><h2 id="组件的数据挂载方式"><a href="#组件的数据挂载方式" class="header-anchor">#</a> 组件的数据挂载方式</h2> <h3 id="状态（state）"><a href="#状态（state）" class="header-anchor">#</a> 状态（state）</h3> <p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p> <h3 id="属性（props）"><a href="#属性（props）" class="header-anchor">#</a> 属性（props）</h3> <p>props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改，但是你可以通过父组件主动重新渲染的方式来传入新的 props属性是描述性质、特点的，组件自己不能随意更改。之前的组件代码里面有 props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为组件 props 对象的键值。通箭头函数创建的组件，需要通过函数的参数来接收 props</p> <h3 id="属性-vs-状态"><a href="#属性-vs-状态" class="header-anchor">#</a> 属性 vs 状态</h3> <p>相似点：都是纯 js 对象，都会触发 render 更新，都具有确定性（状态/属性相同，结果相同）
不同点：</p> <ol><li>属性能从父组件获取，状态不能</li> <li>属性可以由父组件修改，状态不能</li> <li>属性能在内部设置默认值，状态也可以，设置方式不一样</li> <li>属性不在组件内部修改，状态要在组件内部修改</li> <li>属性能设置子组件初始值，状态不可以</li> <li>属性可以修改子组件的值，状态不可以</li></ol> <p><strong>state</strong> 的主要作用是用于组件保存、控制、修改自己的可变状态。state 在组件内部初始化，可以被
组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制
的数据源。state 中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲
染。
<strong>props</strong> 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制无法修改。除非外部组件主动传入新的 props ，否则组件的 props 永远保持不变。没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p> <h4 id="渲染数据"><a href="#渲染数据" class="header-anchor">#</a> 渲染数据</h4> <ol><li>条件渲染</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  condition <span class="token operator">?</span> <span class="token string">'渲染列表的代码'</span> <span class="token operator">:</span> <span class="token string">'空空如也'</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>列表渲染</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数据</span>
<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">'Leo'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">'XiaoMing'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token comment">// 渲染列表</span>
<span class="token punctuation">{</span>
  people<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">person</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>dl key<span class="token operator">=</span><span class="token punctuation">{</span>person<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dt<span class="token operator">&gt;</span><span class="token punctuation">{</span>person<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dt<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dd<span class="token operator">&gt;</span>age<span class="token operator">:</span> <span class="token punctuation">{</span>person<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dd<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>dl<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="组件通信的方式"><a href="#组件通信的方式" class="header-anchor">#</a> .组件通信的方式</h2> <h3 id="父子组件通信方式"><a href="#父子组件通信方式" class="header-anchor">#</a> 父子组件通信方式</h3> <ol><li>传递数据(父传子)与传递方法(子传父)</li> <li>ref 标记 (父组件拿到子组件的引用，从而调用子组件的方法)
如：在父组件中清除子组件的 input 输入框的 value 值。this.refs.form.reset()</li></ol> <h3 id="非父子组件通信方式"><a href="#非父子组件通信方式" class="header-anchor">#</a> 非父子组件通信方式</h3> <ol><li><p>状态提升(中间人模式)
React 中的状态提升概括来说,就是将多个组件需要共享的状态提升到它们最近的父组件上.在父组件上改变这个状态然后通过 props 分发给子组件.</p></li> <li><p>发布订阅模式实现</p></li> <li><p>context 状态树传参</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//a. 先定义全局context对象</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">const</span> GlobalContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> GlobalContext

<span class="token comment">//b. 根组件引入GlobalContext，并使用GlobalContext.Provider（生产者）</span>
<span class="token comment">//重新包装根组件 class App {}</span>
<span class="token operator">&lt;</span>GlobalContext<span class="token punctuation">.</span>Provider
  value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token string">&quot;kerwin&quot;</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">,</span>
    content<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>content<span class="token punctuation">,</span>
    show<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hide<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>之前的根组件<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>之前的根组件<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>GlobalContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>


<span class="token comment">//c. 任意组件引入GlobalContext并调用context，使用GlobalContext.Consumer（消费者）</span>
<span class="token operator">&lt;</span>GlobalContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token parameter">context</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>myshow <span class="token operator">=</span> context<span class="token punctuation">.</span>show<span class="token punctuation">;</span> <span class="token comment">//可以在当前组件任意函数触发</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>myhide <span class="token operator">=</span> context<span class="token punctuation">.</span>hide<span class="token punctuation">;</span><span class="token comment">//可以在当前组件任意函数触发</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>context<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span>context<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span>context<span class="token punctuation">.</span>content<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>GlobalContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
</code></pre></div><p>注意：GlobalContext.Consumer内必须是回调函数，通过context方法改变根组件状态
context优缺点：</p> <ul><li>优点：跨组件访问数据</li> <li>缺点：react组件树种某个上级组件shouldComponetUpdate 返回false,当context更新时，不会引起下级组件更新</li></ul> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> React Hooks</h2> <h3 id="使用hooks理由"><a href="#使用hooks理由" class="header-anchor">#</a> 使用hooks理由</h3> <ol><li>高阶组件为了复用，导致代码层级复杂</li> <li>生命周期的复杂</li> <li>写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高</li></ol> <h3 id="usestate-保存组件状态"><a href="#usestate-保存组件状态" class="header-anchor">#</a> useState(保存组件状态)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span>setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span>
</code></pre></div><h3 id="useeffect-处理副作用-和uselayouteffect-同步执行副作用"><a href="#useeffect-处理副作用-和uselayouteffect-同步执行副作用" class="header-anchor">#</a> useEffect(处理副作用)和useLayoutEffect (同步执行副作用)</h3> <p>Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">//effect</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">//cleanup</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>依赖的状态<span class="token punctuation">;</span>空数组<span class="token punctuation">,</span>表示不依赖<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React 撒了谎，后果就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告</span>
</code></pre></div><h4 id="useeffect和uselayouteffect有什么区别"><a href="#useeffect和uselayouteffect有什么区别" class="header-anchor">#</a> useEffect和useLayoutEffect有什么区别</h4> <p>简单来说就是调用时机不同， useLayoutEffect 和原来componentDidMount &amp; componentDidUpdate 一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect 是会在整个页面渲染完才会调用的代码。<strong>官方建议优先使用useEffect</strong></p> <h3 id="usecallback-记忆函数"><a href="#usecallback-记忆函数" class="header-anchor">#</a> useCallback(记忆函数)</h3> <p>防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用; 只有第二个参数 变化了，才重新声明一次</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token comment">//只有name改变后， 这个函数才会重新声明一次，</span>
<span class="token comment">//如果传入空数组， 那么就是第一次创建后就被缓存， 如果name后期改变了,拿到的还是老的name。</span>
<span class="token comment">//如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name.</span>
</code></pre></div><h3 id="usememo-记忆组件"><a href="#usememo-记忆组件" class="header-anchor">#</a> useMemo 记忆组件</h3> <p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。
<strong>唯一的区别是：useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并
且将函数执行结果返回给你。</strong>
所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件.</p> <h3 id="useref-保存引用值"><a href="#useref-保存引用值" class="header-anchor">#</a> useRef(保存引用值)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myswiper <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>Swiper ref<span class="token operator">=</span><span class="token punctuation">{</span>myswiper<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><h3 id="usereducer和usecontext-减少组件层级"><a href="#usereducer和usecontext-减少组件层级" class="header-anchor">#</a> useReducer和useContext(减少组件层级)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">var</span> GlobalContext<span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 注意此时的reduecer 返回值是一个对象 {isShow:false,list:[]}</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span>dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span><span class="token punctuation">{</span>isShow<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>list<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>GlobalContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    dispatch
  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>isShow
      <span class="token operator">?</span><span class="token operator">&lt;</span>div <span class="token operator">&gt;</span>我是选项卡<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">:</span><span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>GlobalContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Detail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>GlobalContext<span class="token punctuation">)</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//隐藏</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      type<span class="token operator">:</span><span class="token string">&quot;Hide&quot;</span><span class="token punctuation">,</span>
      payload<span class="token operator">:</span><span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">//显示</span>
      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      type<span class="token operator">:</span><span class="token string">&quot;Show&quot;</span><span class="token punctuation">,</span>
      payload<span class="token operator">:</span><span class="token boolean">true</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        detail
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer><!----> <hr> <p class="lastUpdated">最後更新：2022/04/26</p> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#jsx-语法与组件" title="JSX 语法与组件">JSX 语法与组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#jsx-语法" title="JSX 语法">JSX 语法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#class-组件" title="Class 组件">Class 组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#函数式组件" title="函数式组件">函数式组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#组件的样式" title="组件的样式">组件的样式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#事件处理" title="事件处理">事件处理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ref-的应用" title="Ref 的应用">Ref 的应用</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组件的数据挂载方式" title="组件的数据挂载方式">组件的数据挂载方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#状态（state）" title="状态（state）">状态（state）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#属性（props）" title="属性（props）">属性（props）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#属性-vs-状态" title="属性 vs 状态">属性 vs 状态</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组件通信的方式" title=".组件通信的方式">.组件通信的方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#父子组件通信方式" title="父子组件通信方式">父子组件通信方式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#非父子组件通信方式" title="非父子组件通信方式">非父子组件通信方式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#react-hooks" title="React Hooks">React Hooks</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#使用hooks理由" title="使用hooks理由">使用hooks理由</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#usestate-保存组件状态" title="useState(保存组件状态)">useState(保存组件状态)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#useeffect-处理副作用-和uselayouteffect-同步执行副作用" title="useEffect(处理副作用)和useLayoutEffect (同步执行副作用)">useEffect(处理副作用)和useLayoutEffect (同步执行副作用)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#usecallback-记忆函数" title="useCallback(记忆函数)">useCallback(记忆函数)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#usememo-记忆组件" title="useMemo 记忆组件">useMemo 记忆组件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#useref-保存引用值" title="useRef(保存引用值)">useRef(保存引用值)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#usereducer和usecontext-减少组件层级" title="useReducer和useContext(减少组件层级)">useReducer和useContext(减少组件层级)</a></div></div></div></div> <footer class="footer" data-v-9908f194><div class="footer-left-wrap" data-v-9908f194><ul class="contact" data-v-9908f194><li class="contact-item" data-v-9908f194><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-9908f194><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-9908f194></path></svg>
          
        </a></li><li class="contact-item" data-v-9908f194><a href="/me-blog/2022/04/14/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kakigakki@gmail.com.html" class="nav-link" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-9908f194><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-9908f194></path><polyline points="22,6 12,13 2,6" data-v-9908f194></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-9908f194><ul class="copyright" data-v-9908f194></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/me-blog/assets/js/app.4b1a192a.js" defer></script><script src="/me-blog/assets/js/6.28c07464.js" defer></script><script src="/me-blog/assets/js/3.db7e6e2f.js" defer></script><script src="/me-blog/assets/js/21.5ae38ab1.js" defer></script>
  </body>
</html>
