(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{488:function(t,s,a){"use strict";a.r(s);var e=a(8),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[t._v("#")]),t._v(" 双向绑定")]),t._v(" "),a("ul",[a("li",[t._v("vue中可以直接对vue框架规定好的一些页面元素，如input使用v-model指定，直接完成双向绑定。")]),t._v(" "),a("li",[t._v("react在这方面就需要自己动手的地方比较多了，首先在"),a("code",[t._v("input")]),t._v("的"),a("code",[t._v("value")]),t._v("属性绑定一个状态，然后绑定"),a("code",[t._v("onChange")]),t._v("事件当value改变时来手动给状态设定值，已完成双向绑定。")])]),t._v(" "),a("h2",{attrs:{id:"基础父子通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础父子通讯"}},[t._v("#")]),t._v(" 基础父子通讯")]),t._v(" "),a("p",[t._v("父传子都是差不多的，主要差别在于子传父。")]),t._v(" "),a("ul",[a("li",[t._v("vue中需要在子组件中emit一个事件，然后父组件监听这个事件，以完成子父通讯。")]),t._v(" "),a("li",[t._v("react中还是利用父传子时属性传递的思想来完成，但是此时父传给子的是一个回调函数类型的属性，当子完成操作时，调用该函数，就可以触发父组件发生改变。")])]),t._v(" "),a("h2",{attrs:{id:"插槽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插槽"}},[t._v("#")]),t._v(" 插槽")]),t._v(" "),a("ul",[a("li",[t._v("vue中通过slot实现，需要学习slot相关语法与知识")]),t._v(" "),a("li",[t._v("react中还是利用属性的思想完成。只需要在子组件中用"),a("code",[t._v("this.props.children")]),t._v("就可以拿到html片段")])]),t._v(" "),a("h2",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[t._v("如果不使用函数式组件的话，其实React的生命周期和Vue的写法是很像的，都是"),a("code",[t._v("mounted``updated")]),t._v("这一套东西，但是如果React使用了函数式编程的话，两者差别就有点大了。")]),t._v(" "),a("ul",[a("li",[t._v("vue不管是vue2还是vue3其实都是调用生命周期函数。比如：\n"),a("ul",[a("li",[t._v("vue2中用"),a("code",[t._v("mounted(){}")])]),t._v(" "),a("li",[t._v("vue3中用"),a("code",[t._v("onMounted(()=>{})")])])])]),t._v(" "),a("li",[t._v("React的函数式编程中直接使用"),a("code",[t._v("useEffect")]),t._v("来模拟了整个生命周期，十分牛逼。")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第一个参数为回调函数,当组件初始化或者监听对象发生改变时调用 （mounted,updated）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//回调函数的返回值也是一个函数，用来表示组件销毁时的回调函数。(destroyed)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二个参数为监听对象,可以是state或者prop")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"css模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css模块化"}},[t._v("#")]),t._v(" css模块化")]),t._v(" "),a("ul",[a("li",[t._v("vue中应该使用模板,每个模板里都有带着scoped的css标签,不太需要管理css的重复,覆盖问题")]),t._v(" "),a("li",[t._v("react中需要使用"),a("code",[t._v("xxx.module.css")]),t._v("的命名方式对css文件进行命名,将css模块化,然后使用css in js的方式去引用")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" cssClass "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./test.module.css"')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("cssClass"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("active"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n test\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"响应式数据的修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据的修改"}},[t._v("#")]),t._v(" 响应式数据的修改")]),t._v(" "),a("ul",[a("li",[t._v("vue3中直接使用proxy对由"),a("code",[t._v("ref()")]),t._v(","),a("code",[t._v("reactive()")]),t._v("包装过的数据进行深层次的绑定。")]),t._v(" "),a("li",[t._v("react中如果不适用第三方库的话，每次想要修改"),a("code",[t._v("state")]),t._v("都需要深拷贝出一份新的对象，然后再修改这个新对象，再把这个新对象赋给"),a("code",[t._v("state")]),t._v("，如此操作特别麻烦")]),t._v(" "),a("li",[t._v("react中可以使用"),a("code",[t._v("immutable")]),t._v("第三方库来修改state，"),a("code",[t._v("immutable")]),t._v("优点：\n"),a("ul",[a("li",[t._v("每次修改immutable对象都出创建新对象，所以可以直接修改被immutable包装过的state，可以减少代码量")]),t._v(" "),a("li",[t._v("因为如果只是单纯的深拷贝创建新对象赋值给state，性能损耗很大，所以immutable在性能上也做了优化")]),t._v(" "),a("li")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);