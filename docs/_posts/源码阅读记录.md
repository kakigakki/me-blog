---
title: 源码阅读笔记
date: 2022-03-13
author: kaki
location: Tokyo
toc: true
---

# vue-devtools

vue的开发者工具如何打开编辑器的对应文件的？
当点击打开对应文件时，会发送当前附带当前文件信息参数的req
![20220314203116](https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20220314203116.png)
然后调用下面的包来在对应的浏览器中开启文件。


利用`launch-editor` [源码](https://github.com/yyx990803/launch-editor)来猜测你用的什么系统，什么编辑器，从而打开对应的软件。
Nodejs是真的牛逼啊。虽然不知道很多模块的使用方法，但是显然，对系统的操作需求Nodejs大概都能满足吧。


# vue3工具函数

虽然很多函数都是经常见到的，有的东西还是十分耳目一新的。
学习一下Vue中如何【判断各类基本类型，对象，函数，数组的方法】

```ts
export const toTypeString = (value: unknown): string =>
   Object.prototype.toString.call(value)

//map,set,纯对象 用Object.prototype.toString.call
export const isMap = (val: unknown): val is Map<any, any> =>
  toTypeString(val) === '[object Map]'
export const isSet = (val: unknown): val is Set<any> =>
  toTypeString(val) === '[object Set]'
export const isPlainObject = (val: unknown): val is object =>
  toTypeString(val) === '[object Object]'


//函数，字符串，symbol用typeof
export const isFunction = (val: unknown): val is Function =>
  typeof val === 'function'
export const isString = (val: unknown): val is string => typeof val === 'string'
export const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'

//日期用instanceof
export const isDate = (val: unknown): val is Date => val instanceof Date

//普通对象（包括数组）
export const isObject = (val: unknown): val is Record<any, any> =>
  val !== null && typeof val === 'object'

//Promise
export const isPromise = <T = any>(val: unknown): val is Promise<T> => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch)
}

```

## 缓存函数用法

```ts
const cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {
  const cache: Record<string, string> = Object.create(null)
  return ((str: string) => {
    const hit = cache[str]
    return hit || (cache[str] = fn(str))
  }) as any
}

//用例：连字符转驼峰
export const camelize = cacheStringFunction((str: string): string => {
  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))
})
//camelize("on-click") 第一次调用时会执行一次cacheStringFunction的参数函数
//camelize("on-click") 第二次调用时就直接在闭包中的cache对象中获取这个函数了。

```

## 严格相同

严格相当的判断可以使用`Object.is()`
相比于`===`,此方法更严格，`===`弊端：
`NaN===NaN`结果为false,`0===-0`结果为true.

## Object.defineProperty

使用次方法时可以传入下列值


>value——当试图获取属性时所返回的值。
>writable——该属性是否可写。
>enumerable——该属性在for in循环中是否会被枚举。
>configurable——该属性是否可被删除。
>set()——该属性的更新操作所调用的函数。
>get()——获取属性值时所调用的函数。

## 层层筛选

因为各类环境下的全局this不一样，所以为了找全局this,可以使用下面写法。
第一次找调用`getGlobalThis()`时，`_globalThis`肯定找不到，所以开始层层递进筛选。
如果有`globalThis`就用[globalThis](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis#%E8%AF%AD%E6%B3%95)，没有就找`self`(Web Workers),还是没有就找`window`(浏览器),还是没有就继续找`global`(Nodejs)，最后实在找不到就返回`{}`(可能是微信小程序？)
```ts
let _globalThis: any
export const getGlobalThis = (): any => {
  return (
    _globalThis ||
    (_globalThis =
      typeof globalThis !== 'undefined'
        ? globalThis
        : typeof self !== 'undefined'
        ? self
        : typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
        ? global
        : {})
  )
}
```
