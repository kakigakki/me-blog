<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>git学习笔记 | KAKi BLOG</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="
每个客户端本地都储存了项目的所有历史版本（git 人员对其进行极致的压缩）
git 中有区域和对象的概念
   区域：
     工作区
     暂存区
     版本库
   对象
     git 对象：所有的文件的每个版本的内容都是以哈希值名的压缩文件保存在.git 文件夹下的 objects 文件夹里。git 对象代表文件的一次次 ...">
    <link rel="preload" href="/me-blog/assets/css/0.styles.160a852d.css" as="style"><link rel="preload" href="/me-blog/assets/js/app.4b1a192a.js" as="script"><link rel="preload" href="/me-blog/assets/js/6.28c07464.js" as="script"><link rel="preload" href="/me-blog/assets/js/3.db7e6e2f.js" as="script"><link rel="preload" href="/me-blog/assets/js/28.47ac6ea1.js" as="script"><link rel="prefetch" href="/me-blog/assets/js/10.79eede31.js"><link rel="prefetch" href="/me-blog/assets/js/11.55973fd1.js"><link rel="prefetch" href="/me-blog/assets/js/12.9578c04b.js"><link rel="prefetch" href="/me-blog/assets/js/13.dcb99cce.js"><link rel="prefetch" href="/me-blog/assets/js/14.5beb0ec8.js"><link rel="prefetch" href="/me-blog/assets/js/15.f58825d9.js"><link rel="prefetch" href="/me-blog/assets/js/16.3ee014d3.js"><link rel="prefetch" href="/me-blog/assets/js/17.88b8ce45.js"><link rel="prefetch" href="/me-blog/assets/js/18.78fcb414.js"><link rel="prefetch" href="/me-blog/assets/js/19.56424686.js"><link rel="prefetch" href="/me-blog/assets/js/20.d8b5c6da.js"><link rel="prefetch" href="/me-blog/assets/js/21.5ae38ab1.js"><link rel="prefetch" href="/me-blog/assets/js/22.6f9be2d0.js"><link rel="prefetch" href="/me-blog/assets/js/23.1040e7cc.js"><link rel="prefetch" href="/me-blog/assets/js/24.4930b6be.js"><link rel="prefetch" href="/me-blog/assets/js/25.b2addafc.js"><link rel="prefetch" href="/me-blog/assets/js/26.4c8fdf59.js"><link rel="prefetch" href="/me-blog/assets/js/27.d70545a0.js"><link rel="prefetch" href="/me-blog/assets/js/29.d1a8312e.js"><link rel="prefetch" href="/me-blog/assets/js/30.abf11326.js"><link rel="prefetch" href="/me-blog/assets/js/31.66095ccb.js"><link rel="prefetch" href="/me-blog/assets/js/32.48bd6ca5.js"><link rel="prefetch" href="/me-blog/assets/js/33.a394a180.js"><link rel="prefetch" href="/me-blog/assets/js/34.9142e80a.js"><link rel="prefetch" href="/me-blog/assets/js/35.eddeb958.js"><link rel="prefetch" href="/me-blog/assets/js/36.dc234639.js"><link rel="prefetch" href="/me-blog/assets/js/37.d2e7e290.js"><link rel="prefetch" href="/me-blog/assets/js/38.b7b6900f.js"><link rel="prefetch" href="/me-blog/assets/js/39.3ddc72c6.js"><link rel="prefetch" href="/me-blog/assets/js/4.9ce64a3d.js"><link rel="prefetch" href="/me-blog/assets/js/40.04d82849.js"><link rel="prefetch" href="/me-blog/assets/js/41.4bb08b11.js"><link rel="prefetch" href="/me-blog/assets/js/42.91f194df.js"><link rel="prefetch" href="/me-blog/assets/js/43.04bbe10d.js"><link rel="prefetch" href="/me-blog/assets/js/44.c1594f17.js"><link rel="prefetch" href="/me-blog/assets/js/45.5cfd9196.js"><link rel="prefetch" href="/me-blog/assets/js/5.61e04663.js"><link rel="prefetch" href="/me-blog/assets/js/7.7f74546b.js"><link rel="prefetch" href="/me-blog/assets/js/8.a9b0d16e.js"><link rel="prefetch" href="/me-blog/assets/js/9.33795499.js"><link rel="prefetch" href="/me-blog/assets/js/vuejs-paginate.3eb1ed69.js">
    <link rel="stylesheet" href="/me-blog/assets/css/0.styles.160a852d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/me-blog/" class="nav-link home-link">KAKi BLOG </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header> <div class="colorPicker themeColorPicker" data-v-7280d5ff><button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button> <button data-v-7280d5ff></button></div></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/me-blog/" class="nav-link mobile-home-link">KAKi BLOG </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/me-blog/" class="nav-link">编程</a></li><li class="mobile-nav-item"><a href="/me-blog/coding/" class="nav-link">頑張ってね</a></li><li class="mobile-nav-item"><a href="/me-blog/tag/" class="nav-link">标签</a></li><li class="mobile-nav-item"><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external">github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        git学习笔记
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">kaki</span> <span itemprop="address">   in Tokyo</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-06-23T00:00:00.000Z">
      Tue Jun 23 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-f41abf76><a href="/me-blog/tag/javascript" data-v-f41abf76><span data-v-f41abf76>javascript</span></a></li><li class="post-tag" data-v-f41abf76><a href="/me-blog/tag/git" data-v-f41abf76><span data-v-f41abf76>git</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h3 id="分布式的版本控制系统"><a href="#分布式的版本控制系统" class="header-anchor">#</a> 分布式的版本控制系统</h3> <ol><li>每个客户端本地都储存了项目的所有历史版本（git 人员对其进行极致的压缩）</li> <li>git 中有区域和对象的概念
<ul><li>区域：
<ul><li>工作区</li> <li>暂存区</li> <li>版本库</li></ul></li> <li>对象
<ul><li>git 对象：所有的文件的每个版本的内容都是以哈希值名的压缩文件保存在.git 文件夹下的 objects 文件夹里。git 对象代表文件的一次次版本
<ul><li><code>git hash-obejct -w fileUrl</code> ：生成一个键值对存到 .git/objects</li></ul></li> <li>树对象：代表项目的一次次版本
<ul><li><code>git update-index - -add - -cacheinfo 100644 hash text.txt</code> ：往暂存区添加一条记录，（让 git 对象对应文件名）</li></ul></li> <li>提交对象： 我们需要知道的对象，能看到有谁提交了版本，每一个代表项目的一次版本
<ul><li><code>Echo “first commit” | git commit-tree treehash</code> :生成一个提交对象存到.git/objects</li></ul></li></ul></li> <li>对以上对象的查询
<ul><li><code>git cat-file -p hash</code> : 拿到对应对象的内容</li> <li><code>git cat-file -t hash</code> ：拿到对应对象的类型</li></ul></li></ul></li></ol> <h3 id="git-初始化配置"><a href="#git-初始化配置" class="header-anchor">#</a> git 初始化配置</h3> <ol><li>初始化配置 git，用来说明你是谁。</li></ol> <div class="language-git extra-class"><pre class="language-git"><code>git config --global user.name “xxxx”
git config --global user.email xxxxx
</code></pre></div><p>除--global 还--system（对该电脑所有用户都适用），还有啥都不写（只对当前项目有用）</p> <ol><li>git config –list 查看当前的配置</li> <li>删除初始化的全局配置</li></ol> <div class="language-git extra-class"><pre class="language-git"><code>git config --global --unset user.name
git config --global --unset user.email
</code></pre></div><ol><li>修改初始化的全局配置</li></ol> <div class="language-git extra-class"><pre class="language-git"><code>git config --global  user.name <span class="token string">&quot;xxxx&quot;</span>
git config --global  user.email <span class="token string">&quot;xxxx&quot;</span>
</code></pre></div><h3 id="git-的底层命令"><a href="#git-的底层命令" class="header-anchor">#</a> git 的底层命令</h3> <ol><li><code>git init</code> 初始化仓库</li> <li>.git 隐藏文件夹中的文件夹分别为
<img src="https://raw.githubusercontent.com/kakigakki/picBed/master/imgs/20200430005432.png" alt="20200430005432"></li> <li><code>clear</code> 清屏</li> <li><code>echo ‘xxxx’</code> 往控制台输出信息
<ul><li><code>echo ‘xxx’ &gt; test.txt</code> 创建 test 文件，且输入 xxx</li></ul></li> <li><code>ll</code> 遍历当前文件夹</li> <li><code>find</code> 目录名 ：打印对应目录下的子孙文件和目录</li> <li><code>find</code> 目录名 -type f 打印对应目录下的子孙文件</li> <li><code>Rm</code> 文件</li> <li><code>Mv</code> 文件 剪切（重命名）</li> <li><code>Cat</code> 文件，查看文件的内容</li> <li><code>Vim</code> 文件
<ul><li>按 i 进入编辑模式</li> <li>按 esc 退出 i 模式后， :wq 后保存退出</li></ul></li> <li><code>git cat-file -p hash</code> : 拿到对应对象的内容</li> <li><code>git cat-file -t hash</code> ：拿到对应对象的类型</li> <li><code>git ls-files -s</code> 查看暂存区的内容</li></ol> <h3 id="git-的高层命令"><a href="#git-的高层命令" class="header-anchor">#</a> git 的高层命令</h3> <ol><li><code>git add ./</code> 将修改添加到暂存区（其实是提到版本库，再拉回暂存区）
<ul><li><code>git hash-object -w 文件名</code>（修改了多少个工作目录中的文件，这个命令就被执行多少次）</li> <li><code>git update-index …</code></li></ul></li> <li><code>git commit -m “xxxx”</code> 将暂存区提交到版本库
<ul><li><code>git write-tree</code></li> <li><code>git commit-tree</code></li></ul></li> <li><code>git init</code> 初始化新仓库</li> <li><code>git status</code> 检查当前文件的状态
<ul><li>git 中的文件有两种状态
<ul><li>已跟踪 （被 git add 过的文件）
<ul><li>已修改 <code>modified</code></li> <li>已暂存 <code>staged</code></li> <li>已提交 <code>commited</code></li></ul></li> <li>未跟踪 （未被 git add 过的文件）</li></ul></li></ul></li> <li><code>git diff</code> 查看哪些还没有暂存</li> <li><code>git diff –staged</code> 查看哪些修改已经被暂存了，还没提交的</li> <li><code>git commit -m &quot;xxx&quot;</code> 提交+注释</li> <li><code>git commit -a</code> 跳过暂存区直接提交</li> <li><code>git commit -a -m &quot;xxx&quot;</code> 跳过暂存区直接提交</li> <li><code>git mv xxxx xxxx</code> ：此步骤相当于下面三步
<ul><li><code>Mv</code></li> <li><code>Rm</code></li> <li><code>git add</code></li></ul></li> <li><code>git rm xxx</code> ： 此步骤相当于下面两步
<ul><li><code>Rm</code></li> <li><code>git add</code></li></ul></li> <li><code>git log</code> 查看提交记录
<ul><li><code>git log -- oneline</code> 可以简略显示。显示的 hash 值是提交对象</li> <li><code>git log --oneline --decorate --graph --all</code> 查看所有的分支的历史记录</li> <li>太长的命令可以用配别名
<ul><li><code>git config --global alias.xxx &quot;git log --oneline --decorate --graph --all&quot;</code></li></ul></li></ul></li> <li><code>git reflog</code> 查看完整操作记录
<ul><li>查看所有分支的记录，我在本地上配置了 alllog</li></ul></li></ol> <h3 id="git-分支操作"><a href="#git-分支操作" class="header-anchor">#</a> git 分支操作</h3> <ol><li>分支的本质就是一个提交对象</li> <li>HEAD : 是一个指针，它默认指向 master 分支，切换分支时就是让 HEAD 指向不同的分支，每次有新的提交时，HEAD 就会带着当前的分支往前移动（HEAD 移动，分支不会移动）。</li> <li><code>git/refs</code>目录中保存了所有的分支，及其对应的提交对象的 hash 值（每次提交对象被新提交时，hash 值都会改变）</li> <li>切换分支会改变 workspace 中的文件。
<ul><li>每次切换分支前，当前分支一定得是干净的（已提交状态）</li> <li>因为在切换分支时，当前分支有未暂存的新创建的 modified 的文件 或者有未提交的的新创建的 staged 的文件的时候，会把此文件一次带到切换的分支上，会污染切换的分支</li></ul></li> <li>操作命令
<ul><li><code>git branch xxx</code> ：在当前提交对象上创建一个新的分支</li> <li><code>git branch xxx Hash值</code> ：在指定的提交对象上创建新的分支（时光机）</li> <li><code>git branch</code> ：查看分支列表</li> <li><code>git checkout branch</code> 切换分支</li> <li><code>git checkout -b xxx</code> 创建新的分支，并切换至此分支</li> <li><code>git branch -d xxx</code> :删除一个合并了的分支</li> <li><code>git branch -D xxx</code>：强制删除一个分支（不管合并了否）</li> <li><code>git branch -v</code> 可以查看所有分支的最后一次提交</li></ul></li></ol> <h3 id="git-存储"><a href="#git-存储" class="header-anchor">#</a> git 存储</h3> <ol><li>当你大工作做一半，但是有其他小工作要做，又不想提交当前分支的话，可以用存储</li> <li>常用命令
<ul><li><code>git stash</code> 将未完成的 modified 保存到一个栈上</li> <li><code>git stash list</code> 查看栈上有哪些修改</li> <li><code>git stash apply</code> 将保存到栈上的第一个 modified 重新取出</li> <li><code>git stash apply stash@{x}</code> 指定取出哪个 modified</li> <li><code>git statsh drop</code> 删除第一个</li> <li><code>git statsh pop</code> 取出修改，删除栈上的第一个</li></ul></li></ol> <h3 id="git-撤销和重置（主要用下面三个命令"><a href="#git-撤销和重置（主要用下面三个命令" class="header-anchor">#</a> git 撤销和重置（主要用下面三个命令</h3> <ol><li><code>git checkout -- filename :</code> 撤回自己在工作区的修改</li> <li><code>git reset filename</code> 撤回自己在暂存区的修改
<ul><li>相当于 reset 第二步曲的缩写</li></ul></li> <li><code>git commit --amend</code> 再次提交暂存区内已修改的文件(类似撤回自己在版本库的提交，再提交一次)</li></ol> <h3 id="reset"><a href="#reset" class="header-anchor">#</a> reset</h3> <ol><li>三步曲
<ul><li>第一步：<code>git reset --soft HEAD~</code> <ul><li>一步：
<ul><li>动 HEAD，带着当前 branch 一起往前一版本后退（撤销）</li></ul></li> <li>(类似<code>git commit --amend</code>，不过<code>--amend</code>撤回然后提交了）
<code>git reset --soft 提交对象的hash值</code> ：HEAD 带着 branch 去指定的提交对象上</li></ul></li> <li>第二步：<code>git reset [--mixed] HEAD~</code> <ul><li>两步：
<ul><li>动 HEAD ,带着当前 branch 一起撤退</li> <li>动了暂存区。</li></ul></li> <li><code>git reset --mixed</code> 提交对象的 hash 值 ：HEAD 带着 branch 去指定的提交对象上</li> <li>可缩写成：<code>git reset</code></li></ul></li> <li>第三步：<code>git reset --hard HEAD~</code>（reset 命令唯一的危险用法）
<ul><li>三步：
<ul><li>动 HEAD ,带着当前 branch 一起撤退</li> <li>动了暂存区</li> <li>动了工作区（会将工作区的内容覆盖）</li></ul></li> <li>一般撤销工作区用：<code>git checkout --filename</code></li> <li>跳过第一步，第二步，</li> <li>只做第三步：动了工作区</li></ul></li></ul></li></ol> <h3 id="标签"><a href="#标签" class="header-anchor">#</a> 标签</h3> <ol><li>标签跟分支很像，只是分支能动，标签不能动</li> <li>常用命令
<ul><li><code>git tag</code> 查看当前标签名</li> <li><code>git tag &lt;标签名&gt;</code> [可选：提交对象的 hash 值] 新建标签</li> <li><code>git show &lt;标签名&gt;</code> :查看标签</li> <li><code>git tag -d &lt;标签名&gt;</code> ：删除标签</li> <li><code>git checkout &lt;标签名&gt;</code> ：切换到 tag</li> <li>如果当前标签没有分支时，会产生头部分离。需要在当前标签上创建分支</li> <li><code>git checkout -b &lt;分支名&gt;</code></li></ul></li></ol> <h3 id="远程仓库"><a href="#远程仓库" class="header-anchor">#</a> 远程仓库</h3> <ol><li><code>git remote add &lt;别名&gt; url</code> ： 让本地仓库跟远程仓库连起来</li> <li><code>git remote -v</code> ：查看远程仓库</li> <li><code>git remote show 别名</code> ：查看远程仓库的更多信息</li> <li><code>git remote rename 旧别名 新别名</code> ：重命名远程仓库</li> <li><code>git remote rm 别名</code> ：删除远程仓库</li> <li><code>git push 远程仓库别名 分支名</code></li> <li><code>git clone 远程仓url</code> ：将远程仓库拉到本地
<ul><li><code>git clone</code>下来的远程仓库的别名，自动设置成 origin</li></ul></li> <li>自己创建的仓库，可以进行 push,但是如果是从别人的仓库 clone 下来的话，如果没有那个人的成员邀请的话，无法进行 push</li></ol> <h3 id="团队协作流程"><a href="#团队协作流程" class="header-anchor">#</a> 团队协作流程</h3> <ol><li>项目经理初始化远程仓库
<ul><li>在 github 上初始化一个空的仓库</li></ul></li> <li>项目经理创建本地仓库
<ul><li><code>git init</code></li> <li>将源码复制进来</li> <li>修改用户名，修改邮箱</li></ul></li> <li>项目经理将本地仓库跟远程仓库链接起来
<ul><li><code>git remote add 别名 url</code></li></ul></li> <li>项目经理将本地仓库推送到远程仓库
<ul><li>清理 windows 凭据</li> <li><code>git push 别名 分支</code> （输入 github 的用户名，密码，输完后会附带生成远程跟踪分支 xxx/xxx）</li></ul></li> <li>项目成员在自己本地克隆远程仓库
<ul><li><code>git clone 仓库地址</code> <ul><li>默认为远程仓库配了别名 origin</li> <li>附带生成远程跟踪分支 xxx/xxx</li></ul></li></ul></li> <li>项目成员做出贡献
<ul><li><code>git add</code></li> <li><code>git commit</code></li> <li><code>git push</code> 别名 分支（输入 github 的用户名，密码）</li></ul></li> <li>项目经理更新修改
<ul><li><code>git fetch 别名</code>（将修改同步到远程跟踪分支上）</li> <li><code>git merge远程跟踪分支</code>（将同步了的远程跟踪分支与本地分支合并）</li></ul></li></ol> <h3 id="深入理解远程库"><a href="#深入理解远程库" class="header-anchor">#</a> 深入理解远程库</h3> <h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="header-anchor">#</a> 远程跟踪分支</h4> <ol><li>远程跟踪分支是远程分支状态的引用，它们是不能自己移动的，在每次网络通信操作时，自动移动</li> <li>如果本地分支没有跟踪任何远程跟踪分支的话，是无法进行网络通信操作的</li> <li>一个本地分支怎么去跟踪一个远程跟踪分支
<ul><li>当克隆的时候，会自动生成一个 master 本地分支（已经跟踪了对应的远程跟踪分支）</li> <li>在新建其他分支的时候，可以指定想要跟踪的远程跟踪分支
<ul><li><code>git checkout -b</code>本地分支名 远程跟踪分支名</li> <li>或者 <code>git checkout --track</code> 远程跟踪分支名（创建一个跟远程分支同一个名字的本地分支和远程跟踪分支，并让本地分支跟踪远程跟踪分支）</li></ul></li></ul></li> <li>如果没有对应的远程跟踪分支的话，可以用<code>git fetch</code>去远程仓库拿
<ul><li>将一个已经存在的本地分支名，跟踪一个远程跟踪分支
<ul><li><code>git branch -u 远程跟踪分支名</code></li> <li>没有远程跟踪分支的话，无法进行<code>git push</code>,<code>git pull</code>操作</li> <li>可以用<code>gir branch -vv</code>查看当前分支所跟踪的远程跟踪分支</li></ul></li></ul></li></ol> <h4 id="冲突"><a href="#冲突" class="header-anchor">#</a> 冲突</h4> <ol><li>当<code>git pull</code>的时候，没有将暂存区的内容提交时，会冲突</li> <li>当<code>git push</code>的时候，远程仓库的内容已经被修改的时候，会冲突</li></ol> <h4 id="删除远程分支"><a href="#删除远程分支" class="header-anchor">#</a> 删除远程分支</h4> <ol><li><code>git push 仓库别名 --delete 远程分支</code></li> <li><code>git remote prune 仓库别名--dry-run</code> ：列出已经不存在的运程仓库上，仍在跟踪的无用分支</li> <li><code>git remote prune 仓库别名</code> : 清楚上面列出的无用分支</li></ol> <h4 id="pull-request"><a href="#pull-request" class="header-anchor">#</a> Pull request</h4> <ol><li>可以通过<code>fork</code>别人的项目，修别人的 bug，给别人提 request。（此步骤可以用 github 操作，不需要命令行）</li> <li>一般只有大神才会用到。。</li></ol> <h3 id="学习过程笔记"><a href="#学习过程笔记" class="header-anchor">#</a> 学习过程笔记</h3> <ol><li><code>git checkout</code>后面也可以跟提交对象的 hash 值，让 HEAD 移动到对应提交对象</li> <li><code>git branch -f xxxx HEAD~3</code> 强制移动分支 xxxx 到前三个提交对象身上</li> <li><code>git branch -f xxxx 提交对象hash</code> 强制移动分支 xxxx 到某个提交对象</li> <li><code>git checkout HEAD^[HEAD~]</code> 移动 HEAD 到上一个提交对象上
<ul><li>~后面跟数字表示移动几个提交对象</li> <li>^后面跟数字表示移动第几个父提交（当前提交类型为合并提交的情况下）</li> <li>如 <code>git checkout HEAD~2^2</code> 表示向上移动两个提交对象，然后在二叉口，移动到第二个父提交对象
<ul><li>正如你所见，此命令支持链式调用</li></ul></li></ul></li> <li><code>git reset HEAD^</code> 将提交对象重置回上一次提交对象</li> <li><code>git revert HEAD^</code> 创建一个新的提交对象，这个提交对象是上一个提交对象的复刻，此方法比较安全。</li> <li><code>git cherry-pick [hash或者分支名] [hash或者分支名]</code> 此命令可以在当前分支获取其它分支的正在进行的代码，可以接多个 commitHash，命令中接了几个 commitHash,就会获得几个提交对象。
<ul><li><code>cherry-pick</code>还可以让 master 分支直接去拿多个分支，合成大分支</li></ul></li> <li><code>git rebase branchName</code> 将当前的分支线上的若干个目标分支线上不存在的提交对象的 code 与目标分支的 code 结合，并在目标分支下面生成若干个提交对象，提交对象上的还是当前分支
<ul><li>情景：假如自己开发的分支开发到一半，然后之前的 master 分支已经被提交过，这时需要提交完的 master 分支中自己分支里没有的代码时，就可以用这个命令，轻松获得</li> <li><code>git rebase 分支1 分支2</code> 在分支 2 下生成分支 1 和分支 2 结合的提交对象</li></ul></li> <li><code>git rebase -i HEAD~4</code> 可以指定当前提交对象之前的若干个提交对象，
<ul><li>这些提交对象可以排序，也可以删减。来构建自己想要 rebase 的提交对象顺序和个数</li> <li><code>git cherry-pick</code>在知道 hash 的情况下牛逼，相反，这个命令是在不知道 hash 的情况下牛逼，总之两个挺像的</li></ul></li> <li><code>git rebase xxxx master</code> 当处在 xxxx 分支上，且想要与 master 合并时，此步骤可以代替下面两步
<ul><li><code>git checkout master</code></li> <li><code>git merge xxxx</code></li></ul></li> <li>一般能用 hash 值直接定位的地方，也能用<code>HEAD~</code>配合<code>HEAD^</code>来找该地方（相对位置找法）</li> <li>一般能用 hash 值的命令也能用分支名字</li></ol> <h3 id="学习过程笔记-2"><a href="#学习过程笔记-2" class="header-anchor">#</a> 学习过程笔记 2</h3> <ol><li>远程跟踪分支是无法进行手动更新的，只能保持上一次通信时的状态。</li> <li>如果<code>git checkout 远程跟踪分支</code>的话，会产生 HEAD 分离
<ul><li>即变成了<code>git checkout HEAD</code></li></ul></li> <li><code>git fetch</code> <ul><li>与远程仓库进行通信</li> <li>更新远程跟踪分支</li> <li><strong>注意</strong>：<code>git fetch</code> 并不会去改变本地仓库分支的位置。就是单纯的更新远程跟踪分支。</li> <li>即：把远程分支上的内容给下载到了远程跟踪分支上而已。没有再进行其他的操作了。</li></ul></li> <li><code>git pull</code> <ul><li><code>git fetch</code> + <code>git merge</code></li> <li><code>git fetch</code>只是下载。<code>git pull</code>是下载+合并</li></ul></li> <li><code>git pull --rebase</code> <ul><li><code>git fetch</code> + <code>git rebase</code></li></ul></li> <li><code>git merge</code> 与<code>git rebase</code>的优缺点
<ul><li><code>git merge</code> 保留提交树的历史，有时候可能看起来很乱</li> <li><code>git rebase</code> 所有提交都在一条树上，不保留历史。看起来更简洁</li></ul></li></ol> <h3 id="速记"><a href="#速记" class="header-anchor">#</a> 速记</h3> <ol><li><code>ssh-keygen -t rsa -C &quot;gitHub上注册时用的邮箱&quot;</code> :注册 ssh</li></ol></div> <footer><!----> <hr> <p class="lastUpdated">最後更新：2020/07/08</p> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#分布式的版本控制系统" title="分布式的版本控制系统">分布式的版本控制系统</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-初始化配置" title="git 初始化配置">git 初始化配置</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-的底层命令" title="git 的底层命令">git 的底层命令</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-的高层命令" title="git 的高层命令">git 的高层命令</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-分支操作" title="git 分支操作">git 分支操作</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-存储" title="git 存储">git 存储</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#git-撤销和重置（主要用下面三个命令" title="git 撤销和重置（主要用下面三个命令">git 撤销和重置（主要用下面三个命令</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#reset" title="reset">reset</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#标签" title="标签">标签</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#远程仓库" title="远程仓库">远程仓库</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#团队协作流程" title="团队协作流程">团队协作流程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#深入理解远程库" title="深入理解远程库">深入理解远程库</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#学习过程笔记" title="学习过程笔记">学习过程笔记</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#学习过程笔记-2" title="学习过程笔记 2">学习过程笔记 2</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#速记" title="速记">速记</a></div></div></div></div> <footer class="footer" data-v-9908f194><div class="footer-left-wrap" data-v-9908f194><ul class="contact" data-v-9908f194><li class="contact-item" data-v-9908f194><a href="https://github.com/kakigakki" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-9908f194><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-9908f194></path></svg>
          
        </a></li><li class="contact-item" data-v-9908f194><a href="/me-blog/2020/06/23/gitmemo/kakigakki@gmail.com.html" class="nav-link" data-v-9908f194><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-9908f194><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-9908f194></path><polyline points="22,6 12,13 2,6" data-v-9908f194></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-9908f194><ul class="copyright" data-v-9908f194></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/me-blog/assets/js/app.4b1a192a.js" defer></script><script src="/me-blog/assets/js/6.28c07464.js" defer></script><script src="/me-blog/assets/js/3.db7e6e2f.js" defer></script><script src="/me-blog/assets/js/28.47ac6ea1.js" defer></script>
  </body>
</html>
